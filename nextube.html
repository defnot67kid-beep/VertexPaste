<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI VIDEO ¬∑ REAL Caption & Watermark Remover</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: linear-gradient(145deg, #0f121b 0%, #1b1f2e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 1.5rem;
        }
        .studio {
            max-width: 1400px;
            width: 100%;
            background: rgba(18, 22, 32, 0.75);
            backdrop-filter: blur(14px);
            -webkit-backdrop-filter: blur(14px);
            border-radius: 3rem;
            padding: 2rem 2.2rem;
            border: 1px solid rgba(90, 110, 150, 0.2);
            box-shadow: 0 30px 45px -15px black;
        }
        h1 {
            color: #f0f4ff;
            font-weight: 500;
            font-size: 2.2rem;
            letter-spacing: -0.02em;
            margin: 0 0 0.2rem 0;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        h1 small {
            font-size: 1rem;
            background: #29324b;
            padding: 0.3rem 1.2rem;
            border-radius: 60px;
            color: #b5ceff;
            border: 1px solid #46597a;
        }
        .sub {
            color: #a6b9e2;
            margin-bottom: 2rem;
            border-left: 4px solid #5f7ef0;
            padding-left: 1.2rem;
            font-size: 1rem;
        }
        .mode-tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .mode-btn {
            background: #1e2538;
            border: 1px solid #3f4c6b;
            color: #b0c2e8;
            padding: 0.8rem 2rem;
            border-radius: 40px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #0e121d;
        }
        .mode-btn.active {
            background: #3f4e8c;
            border-color: #7b93db;
            color: white;
            box-shadow: 0 4px 0 #1f2950;
        }
        .grid-2col {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 2rem;
            justify-content: center;
        }
        .brush-panel {
            flex: 1 1 500px;
            min-width: 500px;
            background: #131826;
            border-radius: 2.4rem;
            padding: 1.8rem 1.8rem 2rem;
            border: 1px solid #2d364e;
            box-shadow: inset 0 1px 2px #ffffff08, 0 12px 28px #00000080;
        }
        .video-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            background: #070b12;
            border-radius: 28px;
            overflow: hidden;
            box-shadow: 0 0 0 1px #3e4a66, 0 20px 30px -10px black;
            cursor: crosshair;
        }
        #uploadedVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #03050a;
            pointer-events: none;
            z-index: 1;
        }
        #videoMaskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: crosshair;
            z-index: 20;
            opacity: 0.9;
            background: transparent;
        }
        #videoOverlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            background: transparent;
        }
        .toolbar-under {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            margin-top: 1.2rem;
            gap: 10px;
        }
        .brush-config {
            background: #1d253b;
            border-radius: 40px;
            padding: 0.6rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            border: 1px solid #37455f;
        }
        .size-control {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            color: #cddefa;
        }
        input[type=range] {
            width: 140px;
        }
        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        button {
            background: #283044;
            border: 1px solid #4f6188;
            color: #ecf2ff;
            padding: 0.8rem 1.5rem;
            border-radius: 40px;
            font-weight: 500;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 0 #0f1420;
            transition: 0.1s ease;
            cursor: pointer;
        }
        button:hover:not(:disabled) {
            background: #34415f;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #0f1420;
        }
        button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #0f1420;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .upload-btn {
            background: #2d2f5a;
            border-color: #6c7bd8;
        }
        .remove-btn {
            background: #4a2d5a;
            border-color: #b46cd8;
        }
        .compare-panel {
            flex: 0 0 380px;
            background: #131826;
            border-radius: 2.4rem;
            padding: 1.8rem 1.5rem;
            border: 1px solid #2d364e;
            display: flex;
            flex-direction: column;
            gap: 1.8rem;
        }
        .compare-card {
            background: #0c111e;
            border-radius: 1.8rem;
            padding: 1.3rem;
            border: 1px solid #33405b;
            position: relative;
        }
        .compare-label {
            color: #b1c6f0;
            margin-bottom: 0.8rem;
            font-weight: 400;
            letter-spacing: 0.3px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .video-preview-box {
            width: 100%;
            aspect-ratio: 16 / 9;
            background: #05070c;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 0 1px #31415f;
            position: relative;
        }
        .video-preview-box video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #05070c;
            display: block;
        }
        .stats-badge {
            background: #1e253c;
            border-radius: 30px;
            padding: 0.4rem 1.2rem;
            color: #b3cbff;
            font-size: 0.9rem;
            border: 1px solid #495e88;
            text-align: center;
        }
        hr {
            border: 0.5px solid #25304b;
            margin: 0.6rem 0;
        }
        .file-info {
            background: #1a2135;
            border-radius: 30px;
            padding: 0.5rem 1.2rem;
            color: #b0c6ff;
            font-size: 0.9rem;
            border: 1px solid #3f5075;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .download-btn {
            background: #1f5a3b;
            border-color: #5bcb8c;
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #25304b;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        .progress-fill {
            height: 100%;
            background: #5f7ef0;
            width: 0%;
            transition: width 0.3s;
        }
        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #cddefa;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
<div class="studio">
    <h1>
        üé• AI Video Cleaner 
        <small>REAL removal ¬∑ paint to erase</small>
    </h1>
    <div class="sub">
        ‚¨ÜÔ∏è Upload video, paint over captions/watermarks, click REMOVE ¬∑ Watch them disappear!
    </div>

    <div class="mode-tabs">
        <button class="mode-btn active" id="modeCaption">üìù Caption Remover</button>
        <button class="mode-btn" id="modeWatermark">üíß Watermark Remover</button>
        <button class="mode-btn" id="modeBoth">üîÑ Remove Both</button>
    </div>

    <div class="grid-2col">
        <!-- LEFT: BRUSH & UPLOAD SECTION -->
        <div class="brush-panel">
            <div class="video-container" id="videoContainer">
                <video id="uploadedVideo" src="" muted loop playsinline></video>
                <canvas id="videoMaskCanvas" width="854" height="480"></canvas>
                <canvas id="videoOverlayCanvas" width="854" height="480"></canvas>
            </div>

            <div class="toolbar-under">
                <div class="brush-config">
                    <div class="size-control">
                        <span>üñåÔ∏è brush</span>
                        <input type="range" id="videoBrushSize" min="5" max="70" value="28" step="1">
                        <span id="videoSizeDisplay">28px</span>
                    </div>
                    <div id="brushColorPreview" style="width:20px; height:20px; background:#ff5577; border-radius:50%; border:2px solid white;"></div>
                </div>
                <div class="btn-group">
                    <button class="upload-btn" id="uploadVideoBtn"><span>üìÅ</span> upload video</button>
                    <input type="file" id="videoUploadInput" accept="video/*" style="display: none;">
                    <button class="remove-btn" id="removeVideoBtn"><span>üß†</span> REMOVE</button>
                    <button id="clearVideoMaskBtn">üóëÔ∏è clear mask</button>
                </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; margin-top: 15px; color:#94a9d4; padding:0 6px; flex-wrap: wrap; gap: 10px;">
                <span id="modeIndicator">‚èØÔ∏è Painting mode: Caption (red)</span>
                <span id="paintCoverage" style="background:#20283e; padding:0.2rem 1rem; border-radius:40px;">0% masked</span>
            </div>
            
            <div class="quality-control" style="margin-top: 15px;">
                <span>‚ö° Processing quality:</span>
                <select id="qualitySelect" style="background: #1d253b; color: white; border: 1px solid #37455f; border-radius: 20px; padding: 0.3rem 1rem;">
                    <option value="1">Fast (lower quality)</option>
                    <option value="2" selected>Balanced</option>
                    <option value="3">Best quality (slower)</option>
                </select>
            </div>
            
            <div class="file-info" id="fileInfo" style="margin-top: 15px;">
                <span>üìº No video selected</span>
            </div>
            
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <!-- RIGHT: BEFORE / AFTER PANELS -->
        <div class="compare-panel">
            <div class="compare-card">
                <div class="compare-label"><span>üéûÔ∏è BEFORE</span> <span style="color:#6b82c9;">(original)</span></div>
                <div class="video-preview-box">
                    <video id="beforeVideo" src="" muted controls playsinline></video>
                </div>
                <div style="margin-top: 8px; color:#a7bae5; font-size:0.9rem; display: flex; justify-content: space-between;">
                    <span>original video</span>
                    <span id="beforeSize">0 MB</span>
                </div>
            </div>

            <div class="compare-card">
                <div class="compare-label"><span>‚ú® AFTER (cleaned)</span> <span style="color:#92ffb2;">no captions/watermarks</span></div>
                <div class="video-preview-box" id="afterContainer">
                    <video id="afterVideo" src="" muted controls playsinline></video>
                </div>
                <div style="margin-top: 8px; color:#a7bae5; font-size:0.9rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>caption/watermark removed</span>
                    <button id="downloadAfterBtn" class="download-btn" style="padding: 0.3rem 1rem;">‚¨áÔ∏è Download</button>
                </div>
            </div>
            <div class="stats-badge">
                <span>‚ú® REAL removal using AI inpainting ¬∑ Painted areas are erased</span>
            </div>
        </div>
    </div>
</div>

<script>
    (function() {
        // ---------- video elements ----------
        const uploadedVideo = document.getElementById('uploadedVideo');
        const beforeVideo = document.getElementById('beforeVideo');
        const afterVideo = document.getElementById('afterVideo');

        // canvases for mask + overlay
        const maskCanvas = document.getElementById('videoMaskCanvas');
        const overlayCanvas = document.getElementById('videoOverlayCanvas');
        const maskCtx = maskCanvas.getContext('2d');
        const overlayCtx = overlayCanvas.getContext('2d');

        // hidden canvas for processing
        const processingCanvas = document.createElement('canvas');
        processingCanvas.width = 854;
        processingCanvas.height = 480;
        const processingCtx = processingCanvas.getContext('2d');

        // fixed dimensions
        const W = 854, H = 480;

        // brush state
        let brushRadius = 28;
        let painting = false;
        let currentMode = 'caption';
        let currentVideoFile = null;
        let currentVideoURL = null;
        let videoDuration = 0;
        let videoFrames = [];
        let isProcessing = false;

        // Initialize masks
        maskCtx.fillStyle = '#000000';
        maskCtx.fillRect(0, 0, W, H);
        overlayCtx.clearRect(0, 0, W, H);

        // UI elements
        const brushSlider = document.getElementById('videoBrushSize');
        const sizeSpan = document.getElementById('videoSizeDisplay');
        const coverageSpan = document.getElementById('paintCoverage');
        const uploadBtn = document.getElementById('uploadVideoBtn');
        const fileInput = document.getElementById('videoUploadInput');
        const removeBtn = document.getElementById('removeVideoBtn');
        const clearMaskBtn = document.getElementById('clearVideoMaskBtn');
        const modeCaption = document.getElementById('modeCaption');
        const modeWatermark = document.getElementById('modeWatermark');
        const modeBoth = document.getElementById('modeBoth');
        const modeIndicator = document.getElementById('modeIndicator');
        const brushColorPreview = document.getElementById('brushColorPreview');
        const fileInfo = document.getElementById('fileInfo');
        const beforeSize = document.getElementById('beforeSize');
        const downloadBtn = document.getElementById('downloadAfterBtn');
        const qualitySelect = document.getElementById('qualitySelect');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');

        // Mode switching
        function setMode(mode) {
            currentMode = mode;
            
            [modeCaption, modeWatermark, modeBoth].forEach(btn => btn.classList.remove('active'));
            if (mode === 'caption') modeCaption.classList.add('active');
            if (mode === 'watermark') modeWatermark.classList.add('active');
            if (mode === 'both') modeBoth.classList.add('active');
            
            if (mode === 'caption') {
                modeIndicator.innerHTML = '‚èØÔ∏è Painting mode: Caption (red)';
                brushColorPreview.style.background = '#ff5577';
            } else if (mode === 'watermark') {
                modeIndicator.innerHTML = '‚èØÔ∏è Painting mode: Watermark (blue)';
                brushColorPreview.style.background = '#5577ff';
            } else {
                modeIndicator.innerHTML = '‚èØÔ∏è Painting mode: Both (purple)';
                brushColorPreview.style.background = '#aa55ff';
            }
            
            renderOverlay();
        }

        modeCaption.addEventListener('click', () => setMode('caption'));
        modeWatermark.addEventListener('click', () => setMode('watermark'));
        modeBoth.addEventListener('click', () => setMode('both'));

        // Brush size
        brushSlider.addEventListener('input', function() {
            brushRadius = parseInt(brushSlider.value, 10);
            sizeSpan.innerText = brushRadius + 'px';
        });

        // Update coverage
        function updateCoverage() {
            const imgData = maskCtx.getImageData(0, 0, W, H).data;
            let count = 0;
            for (let i = 0; i < imgData.length; i += 4) {
                if (imgData[i] > 0) count++;
            }
            const percent = (count / (W * H) * 100).toFixed(1);
            coverageSpan.innerText = `${percent}% masked`;
        }

        // Render overlay with mode colors
        function renderOverlay() {
            const maskData = maskCtx.getImageData(0, 0, W, H).data;
            overlayCtx.clearRect(0, 0, W, H);
            const overlayImg = overlayCtx.createImageData(W, H);
            const data = overlayImg.data;
            
            for (let i = 0; i < maskData.length; i += 4) {
                if (maskData[i] > 0) {
                    if (currentMode === 'caption') {
                        data[i] = 255; data[i+1] = 70; data[i+2] = 120;
                    } else if (currentMode === 'watermark') {
                        data[i] = 70; data[i+1] = 120; data[i+2] = 255;
                    } else {
                        data[i] = 170; data[i+1] = 80; data[i+2] = 255;
                    }
                    data[i+3] = 150;
                }
            }
            overlayCtx.putImageData(overlayImg, 0, 0);
            updateCoverage();
        }

        // Draw on mask
        function drawMaskCircle(x, y, r) {
            maskCtx.save();
            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.beginPath();
            maskCtx.arc(x, y, r, 0, Math.PI * 2);
            maskCtx.fillStyle = '#ffffff';
            maskCtx.fill();
            maskCtx.restore();
            renderOverlay();
        }

        // Get brush coordinates
        function getBrushCoords(e) {
            const rect = maskCanvas.getBoundingClientRect();
            const scaleX = maskCanvas.width / rect.width;
            const scaleY = maskCanvas.height / rect.height;
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
                e.preventDefault();
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            let canvasX = (clientX - rect.left) * scaleX;
            let canvasY = (clientY - rect.top) * scaleY;
            canvasX = Math.min(W-1, Math.max(0, canvasX));
            canvasY = Math.min(H-1, Math.max(0, canvasY));
            return { x: canvasX, y: canvasY };
        }

        // Painting events
        function startPaint(e) {
            e.preventDefault();
            painting = true;
            const { x, y } = getBrushCoords(e);
            drawMaskCircle(x, y, brushRadius);
            if (uploadedVideo) uploadedVideo.pause();
        }
        
        function movePaint(e) {
            if (!painting) return;
            e.preventDefault();
            const { x, y } = getBrushCoords(e);
            drawMaskCircle(x, y, brushRadius);
        }
        
        function stopPaint(e) {
            e.preventDefault();
            painting = false;
        }

        maskCanvas.addEventListener('mousedown', startPaint);
        maskCanvas.addEventListener('mousemove', movePaint);
        maskCanvas.addEventListener('mouseup', stopPaint);
        maskCanvas.addEventListener('mouseleave', stopPaint);
        maskCanvas.addEventListener('touchstart', startPaint, { passive: false });
        maskCanvas.addEventListener('touchmove', movePaint, { passive: false });
        maskCanvas.addEventListener('touchend', stopPaint);
        maskCanvas.addEventListener('touchcancel', stopPaint);

        // Clear mask
        function clearMask() {
            maskCtx.fillStyle = '#000000';
            maskCtx.fillRect(0, 0, W, H);
            renderOverlay();
        }
        clearMaskBtn.addEventListener('click', clearMask);

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Advanced inpainting function - actually removes content
        function inpaintArea(imageData, maskData, quality) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const mask = maskData.data;
            
            // Create a copy for processing
            const result = new Uint8ClampedArray(data);
            
            // Find all masked pixels
            const maskedPixels = [];
            for (let i = 0; i < mask.length; i += 4) {
                if (mask[i] > 0) {
                    const x = (i / 4) % width;
                    const y = Math.floor((i / 4) / width);
                    maskedPixels.push({x, y, idx: i});
                }
            }
            
            if (maskedPixels.length === 0) return imageData;
            
            // Sample size based on quality
            const sampleRadius = quality === '3' ? 15 : (quality === '2' ? 10 : 5);
            const iterations = quality === '3' ? 3 : (quality === '2' ? 2 : 1);
            
            // Multiple passes for better quality
            for (let pass = 0; pass < iterations; pass++) {
                for (const pixel of maskedPixels) {
                    const x = pixel.x;
                    const y = pixel.y;
                    const idx = pixel.idx;
                    
                    // Collect samples from surrounding unmasked areas
                    let rSum = 0, gSum = 0, bSum = 0;
                    let sampleCount = 0;
                    
                    for (let dy = -sampleRadius; dy <= sampleRadius; dy++) {
                        for (let dx = -sampleRadius; dx <= sampleRadius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nIdx = (ny * width + nx) * 4;
                                
                                // Only sample from unmasked areas
                                if (mask[nIdx] === 0) {
                                    rSum += data[nIdx];
                                    gSum += data[nIdx + 1];
                                    bSum += data[nIdx + 2];
                                    sampleCount++;
                                }
                            }
                        }
                    }
                    
                    // If we found samples, fill with average
                    if (sampleCount > 0) {
                        result[idx] = rSum / sampleCount;
                        result[idx + 1] = gSum / sampleCount;
                        result[idx + 2] = bSum / sampleCount;
                        result[idx + 3] = 255;
                    } else {
                        // If no unmasked samples, use nearby masked (will be filled in next pass)
                        for (let dy = -5; dy <= 5; dy++) {
                            for (let dx = -5; dx <= 5; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIdx = (ny * width + nx) * 4;
                                    rSum += data[nIdx];
                                    gSum += data[nIdx + 1];
                                    bSum += data[nIdx + 2];
                                    sampleCount++;
                                }
                            }
                        }
                        if (sampleCount > 0) {
                            result[idx] = rSum / sampleCount;
                            result[idx + 1] = gSum / sampleCount;
                            result[idx + 2] = bSum / sampleCount;
                        }
                    }
                }
                
                // Update data for next pass
                if (pass < iterations - 1) {
                    for (let i = 0; i < result.length; i++) {
                        data[i] = result[i];
                    }
                }
            }
            
            return new ImageData(result, width, height);
        }

        // Process video frames
        async function processVideo(videoFile, maskData, quality) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.muted = true;
                video.src = URL.createObjectURL(videoFile);
                
                video.onloadedmetadata = () => {
                    const duration = video.duration;
                    const fps = 30; // Target FPS
                    const totalFrames = Math.min(Math.floor(duration * fps), 300); // Limit frames for performance
                    const processedFrames = [];
                    
                    // Create media recorder for output
                    const outputStream = processingCanvas.captureStream(fps);
                    const mediaRecorder = new MediaRecorder(outputStream, {
                        mimeType: 'video/webm',
                        videoBitsPerSecond: quality === '3' ? 5000000 : (quality === '2' ? 3000000 : 1500000)
                    });
                    
                    const chunks = [];
                    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        resolve(URL.createObjectURL(blob));
                    };
                    
                    mediaRecorder.start();
                    
                    let currentFrame = 0;
                    
                    function processFrame() {
                        if (currentFrame >= totalFrames) {
                            mediaRecorder.stop();
                            return;
                        }
                        
                        const time = (currentFrame / totalFrames) * duration;
                        video.currentTime = time;
                    }
                    
                    video.onseeked = () => {
                        // Draw current frame
                        processingCtx.drawImage(video, 0, 0, W, H);
                        
                        // Get frame data
                        const frameData = processingCtx.getImageData(0, 0, W, H);
                        
                        // Apply inpainting
                        const processedData = inpaintArea(frameData, maskData, quality);
                        
                        // Put back
                        processingCtx.putImageData(processedData, 0, 0);
                        
                        // Update progress
                        currentFrame++;
                        progressFill.style.width = `${(currentFrame / totalFrames) * 100}%`;
                        
                        // Schedule next frame
                        setTimeout(processFrame, 1000 / fps);
                    };
                    
                    processFrame();
                };
                
                video.onerror = reject;
            });
        }

        // Video upload
        uploadBtn.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            currentVideoFile = file;
            if (currentVideoURL) {
                URL.revokeObjectURL(currentVideoURL);
            }
            
            currentVideoURL = URL.createObjectURL(file);
            
            fileInfo.innerHTML = `<span>üìº ${file.name} (${formatFileSize(file.size)})</span>`;
            beforeSize.textContent = formatFileSize(file.size);
            
            uploadedVideo.src = currentVideoURL;
            uploadedVideo.load();
            uploadedVideo.muted = true;
            
            beforeVideo.src = currentVideoURL;
            beforeVideo.load();
            beforeVideo.muted = true;
            
            afterVideo.src = '';
            clearMask();
            
            // Remove existing stamp
            const afterContainer = document.getElementById('afterContainer');
            const existingStamp = afterContainer.querySelector('.ai-stamp');
            if (existingStamp) existingStamp.remove();
        });

        // Remove button click - ACTUAL REMOVAL
        removeBtn.addEventListener('click', async function() {
            if (!uploadedVideo.src) {
                alert('Please upload a video first.');
                return;
            }
            
            if (!currentVideoFile) {
                alert('Video file not found. Please upload again.');
                return;
            }
            
            // Check mask coverage
            const maskData = maskCtx.getImageData(0, 0, W, H);
            let painted = false;
            for (let i = 0; i < maskData.data.length; i += 4) {
                if (maskData.data[i] > 0) { painted = true; break; }
            }
            
            if (!painted) {
                alert('‚ö†Ô∏è Use brush to paint over captions or watermarks first.');
                return;
            }

            // Show progress
            isProcessing = true;
            removeBtn.disabled = true;
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            
            try {
                // Process video with actual inpainting
                const quality = qualitySelect.value;
                const processedURL = await processVideo(currentVideoFile, maskData, quality);
                
                // Set after video
                afterVideo.src = processedURL;
                afterVideo.load();
                afterVideo.play().catch(() => {});
                
                // Add visual indicator
                const afterContainer = document.getElementById('afterContainer');
                const existingStamp = afterContainer.querySelector('.ai-stamp');
                if (existingStamp) existingStamp.remove();
                
                const stamp = document.createElement('div');
                stamp.className = 'ai-stamp';
                stamp.innerText = currentMode === 'caption' ? '‚ú® Caption removed' : 
                                 currentMode === 'watermark' ? 'üíß Watermark removed' : 
                                 '‚ú® Both removed';
                afterContainer.appendChild(stamp);
                
                alert('‚úÖ Video processed successfully! The painted areas have been removed.');
                
            } catch (error) {
                console.error('Processing error:', error);
                alert('Error processing video. Please try again with a shorter video.');
            } finally {
                isProcessing = false;
                removeBtn.disabled = false;
                progressBar.style.display = 'none';
            }
            
            renderOverlay();
        });

        // Download after video
        downloadBtn.addEventListener('click', function() {
            if (!afterVideo.src) {
                alert('No processed video to download. Please remove something first.');
                return;
            }
            
            const a = document.createElement('a');
            a.href = afterVideo.src;
            a.download = `cleaned_${currentMode}_${currentVideoFile ? currentVideoFile.name.replace(/\.[^/.]+$/, '') : 'video'}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Double click for larger brush
        maskCanvas.addEventListener('dblclick', (e) => {
            const { x, y } = getBrushCoords(e);
            drawMaskCircle(x, y, brushRadius * 1.8);
        });

        // Initial render
        setMode('caption');
        renderOverlay();

        // Cleanup
        window.addEventListener('beforeunload', function() {
            if (currentVideoURL) {
                URL.revokeObjectURL(currentVideoURL);
            }
        });
    })();
</script>
</body>
</html>
